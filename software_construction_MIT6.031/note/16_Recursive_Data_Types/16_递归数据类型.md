# 递归数据类型
> 一个经典的递归数据类型:不可变列表

## 不可变列表
定义以下数据结构:
<table class="table table-condensed no-markdown" id="@empty_void_imlist_returns_empty_list"><tbody><tr><th>empty: void → ImList</th><td>// 返回空白列表</td></tr><tr><th style="white-space:nowrap">cons: E × ImList → ImList </th><td>// 在一个列表的前面加入元素并且返回这个新形成的列表</td></tr><tr><th>head: ImList → E</th><td>// 当列表非空时 ,  返回列表第一个元素</td></tr><tr><th>tail: ImList → ImList</th><td>// 列表非空时 , 返回除了第一个以外的所有元素</td></tr></tbody></table>

### 在java中的实现
```java
// declares a gene-type ImList<E>
public interface ImList<E> {
    public static <E> ImList<E> empty(){
        return new Empty<>();
    }
    public ImList<E> cons(E element);
    public E head();
    public ImList tail();
}

// implement emt & cons
public class Empty<E> implements ImList<E> {
    public Empty(){

    }
    public ImList<E> cons(E element){
        return new Cons<>(element , this);
    }
    public E head(){
        throw new UnsupportedOperationException();
    }
    public ImList<E> tail(){
        throw new UnsupportOperationException();
    }
}

public class Cons<E> implements ImList<E> {
    private final E element;
    private final ImList<E> tail;

    public Cons(E element , ImList<E> tail){
        this.element = element;
        this.tail = tail;
    }

    public ImList<E> cons(E element){
        return new Cons<>(element , this);
    }

    public E head(){
        return element;
    }

    public ImList<E> tail(){
        return tail;
    }
}
```

## 递归数据类型定义
抽象数据类型ImList的两个实现在自己的rep中又使用了ImList,形成了递归

`ImList<E> = Empty + Cons(elt:E , tail:ImList<E>)`

## 递归数据类型上的函数
- 实现**Size : ImList -> int** //返回列表值
```java
size(Cons(elt:E , tail:ImList)) = 1 + size(tail)
```

- 实现**isEmpty : ImList -> boolean**
```java
isEmpty(Cons(elt:E , tail:ImList)) = false
```

- 实现**contains : ImList * E -> boolean**
```java
contains(Cons(elt:E , tail:ImList) ,e:E) = e Or contains(tail , e)
```

- 实现**get:ImList * int -> E**
```java
get(Cons(e ,  tail) , n:int) = if n=0 then elt else get(tail , n-1)
```

- 实现**append : ImList * ImList -> ImList**
```java
append(Cons(e , tail) , list2) = cons(e , append(tail , list2))
```

- 实现**reverse : ImList -> ImList**
```java
reverse(Cons(e , tail)) = append(reverse(tail) , cons(e , empty()))
```

### 调整rep
现在size的实现是O(n)的,我们通过修改列表的rep,在第一次计算时缓存大小,这样以后使用O(1)的时间即可获取

```java
public class Cons<E> implements ImList<E> {
    ...
    private int size = 0;

    // rep invariant 
    // e != null , tail != null , size >= 0
    // size > 0 implies size == 1+tail.size()

    ...
    public int size(){
        if (size == 0) size = 1 + tail.size();
        return size;
    }
}
```

### 重新审视rep独立性
尽管在不可变类型ImList中塞入了一个可变的数值,但其rep并没有对外暴露,没有突变风险,我们仍然认为这是一个不可变对象,且认为这是一个有益的突变

## Null vs Empty
请抵制使用null的诱惑
使用空对象而不是空引用,使其拥有了对象的泛性特性,便于测试
## Declared type vs actual type
在编译时每个变量都有声明类型,即静态类型
但在运行时每个对象还有一个实际类型,称为动态类型,是由对象的构造函数赋予的.

## 布尔公式与递归数据类型
> (P [**∨**](https://en.wikipedia.org/wiki/Logical_disjunction) Q) [**∧**](https://en.wikipedia.org/wiki/Logical_conjunction) ([**¬**](https://en.wikipedia.org/wiki/Logical_negation)P [**∨**](https://en.wikipedia.org/wiki/Logical_disjunction) R)
which means “either P or Q is true, _and_ either P is false or R is true.”

